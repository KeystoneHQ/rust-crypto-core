pub mod error {
    use thiserror::Error;
    use num_derive::FromPrimitive;
    /// Errors that may be returned by the TokenSwap program.
    #[derive(Clone, Debug, Eq, Error, FromPrimitive, PartialEq)]
    pub enum SwapError {
        // 0.
        /// The account cannot be initialized because it is already being used.
        #[error("Swap account already in use")]
        AlreadyInUse,
        /// The program address provided doesn't match the value generated by the program.
        #[error("Invalid program address generated from bump seed and key")]
        InvalidProgramAddress,
        /// The owner of the input isn't set to the program address generated by the program.
        #[error("Input account owner is not the program address")]
        InvalidOwner,
        /// The owner of the pool token output is set to the program address generated by the program.
        #[error("Output pool account owner cannot be the program address")]
        InvalidOutputOwner,
        /// The deserialization of the account returned something besides State::Mint.
        #[error("Deserialized account is not an SPL Token mint")]
        ExpectedMint,

        // 5.
        /// The deserialization of the account returned something besides State::Account.
        #[error("Deserialized account is not an SPL Token account")]
        ExpectedAccount,
        /// The input token account is empty.
        #[error("Input token account empty")]
        EmptySupply,
        /// The pool token mint has a non-zero supply.
        #[error("Pool token mint has a non-zero supply")]
        InvalidSupply,
        /// The provided token account has a delegate.
        #[error("Token account has a delegate")]
        InvalidDelegate,
        /// The input token is invalid for swap.
        #[error("InvalidInput")]
        InvalidInput,

        // 10.
        /// Address of the provided swap token account is incorrect.
        #[error("Address of the provided swap token account is incorrect")]
        IncorrectSwapAccount,
        /// Address of the provided pool token mint is incorrect
        #[error("Address of the provided pool token mint is incorrect")]
        IncorrectPoolMint,
        /// The output token is invalid for swap.
        #[error("InvalidOutput")]
        InvalidOutput,
        /// General calculation failure due to overflow or underflow
        #[error("General calculation failure due to overflow or underflow")]
        CalculationFailure,
        /// Invalid instruction number passed in.
        #[error("Invalid instruction")]
        InvalidInstruction,

        // 15.
        /// Swap input token accounts have the same mint
        #[error("Swap input token accounts have the same mint")]
        RepeatedMint,
        /// Swap instruction exceeds desired slippage limit
        #[error("Swap instruction exceeds desired slippage limit")]
        ExceededSlippage,
        /// The provided token account has a close authority.
        #[error("Token account has a close authority")]
        InvalidCloseAuthority,
        /// The pool token mint has a freeze authority.
        #[error("Pool token mint has a freeze authority")]
        InvalidFreezeAuthority,
        /// The pool fee token account is incorrect
        #[error("Pool fee token account incorrect")]
        IncorrectFeeAccount,

        // 20.
        /// Given pool token amount results in zero trading tokens
        #[error("Given pool token amount results in zero trading tokens")]
        ZeroTradingTokens,
        /// The fee calculation failed due to overflow, underflow, or unexpected 0
        #[error("Fee calculation failed due to overflow, underflow, or unexpected 0")]
        FeeCalculationFailure,
        /// ConversionFailure
        #[error("Conversion to u64 failed with an overflow or underflow")]
        ConversionFailure,
        /// The provided fee does not match the program owner's constraints
        #[error("The provided fee does not match the program owner's constraints")]
        InvalidFee,
        /// The provided token program does not match the token program expected by the swap
        #[error("The provided token program does not match the token program expected by the swap")]
        IncorrectTokenProgramId,

        // 25.
        /// The provided curve type is not supported by the program owner
        #[error("The provided curve type is not supported by the program owner")]
        UnsupportedCurveType,
        /// The provided curve parameters are invalid
        #[error("The provided curve parameters are invalid")]
        InvalidCurve,
        /// The operation cannot be performed on the given curve
        #[error("The operation cannot be performed on the given curve")]
        UnsupportedCurveOperation,
    }

}

pub mod curve {
    pub mod calculator {
        use std::fmt::Debug;
        use crate::solana_lib::spl::token_swap::error::SwapError;

        pub const INITIAL_SWAP_POOL_AMOUNT: u128 = 1_000_000_000;

        /// Trait for packing of trait objects, required because structs that implement
        /// `Pack` cannot be used as trait objects (as `dyn Pack`).
        pub trait DynPack {
            /// Only required function is to pack given a trait object
            fn pack_into_slice(&self, dst: &mut [u8]);
        }


        /// The direction of a trade, since curves can be specialized to treat each
        /// token differently (by adding offsets or weights)
        #[cfg_attr(feature = "fuzz", derive(Arbitrary))]
        #[repr(C)]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TradeDirection {
            /// Input token A, output token B
            AtoB,
            /// Input token B, output token A
            BtoA,
        }

        /// The direction to round.  Used for pool token to trading token conversions to
        /// avoid losing value on any deposit or withdrawal.
        #[repr(C)]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RoundDirection {
            /// Floor the value, ie. 1.9 => 1, 1.1 => 1, 1.5 => 1
            Floor,
            /// Ceiling the value, ie. 1.9 => 2, 1.1 => 2, 1.5 => 2
            Ceiling,
        }

        /// Encodes results of depositing both sides at once
        #[derive(Debug, PartialEq)]
        pub struct TradingTokenResult {
            /// Amount of token A
            pub token_a_amount: u128,
            /// Amount of token B
            pub token_b_amount: u128,
        }


        /// Trait representing operations required on a swap curve
        pub trait CurveCalculator: Debug + DynPack {
            /// Calculate how much destination token will be provided given an amount
            /// of source token.
            fn swap_without_fees(
                &self,
                source_amount: u128,
                swap_source_amount: u128,
                swap_destination_amount: u128,
                trade_direction: TradeDirection,
            ) -> Option<SwapWithoutFeesResult>;

            /// Get the supply for a new pool
            /// The default implementation is a Balancer-style fixed initial supply
            fn new_pool_supply(&self) -> u128 {
                INITIAL_SWAP_POOL_AMOUNT
            }

            /// Get the amount of trading tokens for the given amount of pool tokens,
            /// provided the total trading tokens and supply of pool tokens.
            fn pool_tokens_to_trading_tokens(
                &self,
                pool_tokens: u128,
                pool_token_supply: u128,
                swap_token_a_amount: u128,
                swap_token_b_amount: u128,
                round_direction: RoundDirection,
            ) -> Option<TradingTokenResult>;

            /// Get the amount of pool tokens for the deposited amount of token A or B.
            ///
            /// This is used for single-sided deposits.  It essentially performs a swap
            /// followed by a deposit.  Because a swap is implicitly performed, this will
            /// change the spot price of the pool.
            ///
            /// See more background for the calculation at:
            ///
            /// <https://balancer.finance/whitepaper/#single-asset-deposit-withdrawal>
            fn deposit_single_token_type(
                &self,
                source_amount: u128,
                swap_token_a_amount: u128,
                swap_token_b_amount: u128,
                pool_supply: u128,
                trade_direction: TradeDirection,
            ) -> Option<u128>;

            /// Get the amount of pool tokens for the withdrawn amount of token A or B.
            ///
            /// This is used for single-sided withdrawals and owner trade fee
            /// calculation. It essentially performs a withdrawal followed by a swap.
            /// Because a swap is implicitly performed, this will change the spot price
            /// of the pool.
            ///
            /// See more background for the calculation at:
            ///
            /// <https://balancer.finance/whitepaper/#single-asset-deposit-withdrawal>
            fn withdraw_single_token_type_exact_out(
                &self,
                source_amount: u128,
                swap_token_a_amount: u128,
                swap_token_b_amount: u128,
                pool_supply: u128,
                trade_direction: TradeDirection,
            ) -> Option<u128>;

            /// Validate that the given curve has no invalid parameters
            fn validate(&self) -> Result<(), SwapError>;

            /// Validate the given supply on initialization. This is useful for curves
            /// that allow zero supply on one or both sides, since the standard constant
            /// product curve must have a non-zero supply on both sides.
            fn validate_supply(&self, token_a_amount: u64, token_b_amount: u64) -> Result<(), SwapError> {
                if token_a_amount == 0 {
                    return Err(SwapError::EmptySupply);
                }
                if token_b_amount == 0 {
                    return Err(SwapError::EmptySupply);
                }
                Ok(())
            }

            /// Some curves function best and prevent attacks if we prevent deposits
            /// after initialization.  For example, the offset curve in `offset.rs`,
            /// which fakes supply on one side of the swap, allows the swap creator
            /// to steal value from all other depositors.
            fn allows_deposits(&self) -> bool {
                true
            }

            /// Calculates the total normalized value of the curve given the liquidity
            /// parameters.
            ///
            /// This value must have the dimension of `tokens ^ 1` For example, the
            /// standard Uniswap invariant has dimension `tokens ^ 2` since we are
            /// multiplying two token values together.  In order to normalize it, we
            /// also need to take the square root.
            ///
            /// This is useful for testing the curves, to make sure that value is not
            /// lost on any trade.  It can also be used to find out the relative value
            /// of pool tokens or liquidity tokens.
            fn normalized_value(
                &self,
                swap_token_a_amount: u128,
                swap_token_b_amount: u128,
            ) -> Option<PreciseNumber>;
        }

        /// Encodes all results of swapping from a source token to a destination token
        #[derive(Debug, PartialEq)]
        pub struct SwapWithoutFeesResult {
            /// Amount of source token swapped
            pub source_amount_swapped: u128,
            /// Amount of destination token swapped
            pub destination_amount_swapped: u128,
        }

    }

    pub mod base {
        use std::sync::Arc;
        use crate::solana_lib::spl::token_swap::curve::calculator::CurveCalculator;

        /// Curve types supported by the token-swap program.
        #[cfg_attr(feature = "fuzz", derive(Arbitrary))]
        #[repr(C)]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CurveType {
            /// Uniswap-style constant product curve, invariant = token_a_amount * token_b_amount
            ConstantProduct,
            /// Flat line, always providing 1:1 from one token to another
            ConstantPrice,
            /// Stable, like uniswap, but with wide zone of 1:1 instead of one point
            Stable,
            /// Offset curve, like Uniswap, but the token B side has a faked offset
            Offset,
        }

        /// Concrete struct to wrap around the trait object which performs calculation.
        #[repr(C)]
        #[derive(Debug)]
        pub struct SwapCurve {
            /// The type of curve contained in the calculator, helpful for outside
            /// queries
            pub curve_type: CurveType,
            /// The actual calculator, represented as a trait object to allow for many
            /// different types of curves
            pub calculator: Arc<dyn CurveCalculator + Sync + Send>,
        }

    }
    pub mod fees {
        /// Encapsulates all fee information and calculations for swap operations
        #[derive(Clone, Debug, Default, PartialEq)]
        pub struct Fees {
            /// Trade fees are extra token amounts that are held inside the token
            /// accounts during a trade, making the value of liquidity tokens rise.
            /// Trade fee numerator
            pub trade_fee_numerator: u64,
            /// Trade fee denominator
            pub trade_fee_denominator: u64,

            /// Owner trading fees are extra token amounts that are held inside the token
            /// accounts during a trade, with the equivalent in pool tokens minted to
            /// the owner of the program.
            /// Owner trade fee numerator
            pub owner_trade_fee_numerator: u64,
            /// Owner trade fee denominator
            pub owner_trade_fee_denominator: u64,

            /// Owner withdraw fees are extra liquidity pool token amounts that are
            /// sent to the owner on every withdrawal.
            /// Owner withdraw fee numerator
            pub owner_withdraw_fee_numerator: u64,
            /// Owner withdraw fee denominator
            pub owner_withdraw_fee_denominator: u64,

            /// Host fees are a proportion of the owner trading fees, sent to an
            /// extra account provided during the trade.
            /// Host trading fee numerator
            pub host_fee_numerator: u64,
            /// Host trading fee denominator
            pub host_fee_denominator: u64,
        }
    }
}


pub mod instruction {
    use crate::solana_lib::spl::token_swap::curve::base::SwapCurve;
    use crate::solana_lib::spl::token_swap::curve::fees::Fees;

    /// Initialize instruction data
    #[repr(C)]
    #[derive(Debug, PartialEq)]
    pub struct Initialize {
        /// all swap fees
        pub fees: Fees,
        /// swap curve info for pool, including CurveType and anything
        /// else that may be required
        pub swap_curve: SwapCurve,
    }

    /// Swap instruction data
    #[cfg_attr(feature = "fuzz", derive(Arbitrary))]
    #[repr(C)]
    #[derive(Clone, Debug, PartialEq)]
    pub struct Swap {
        /// SOURCE amount to transfer, output to DESTINATION is based on the exchange rate
        pub amount_in: u64,
        /// Minimum amount of DESTINATION token to output, prevents excessive slippage
        pub minimum_amount_out: u64,
    }

    /// DepositAllTokenTypes instruction data
    #[cfg_attr(feature = "fuzz", derive(Arbitrary))]
    #[repr(C)]
    #[derive(Clone, Debug, PartialEq)]
    pub struct DepositAllTokenTypes {
        /// Pool token amount to transfer. token_a and token_b amount are set by
        /// the current exchange rate and size of the pool
        pub pool_token_amount: u64,
        /// Maximum token A amount to deposit, prevents excessive slippage
        pub maximum_token_a_amount: u64,
        /// Maximum token B amount to deposit, prevents excessive slippage
        pub maximum_token_b_amount: u64,
    }

    /// WithdrawAllTokenTypes instruction data
    #[cfg_attr(feature = "fuzz", derive(Arbitrary))]
    #[repr(C)]
    #[derive(Clone, Debug, PartialEq)]
    pub struct WithdrawAllTokenTypes {
        /// Amount of pool tokens to burn. User receives an output of token a
        /// and b based on the percentage of the pool tokens that are returned.
        pub pool_token_amount: u64,
        /// Minimum amount of token A to receive, prevents excessive slippage
        pub minimum_token_a_amount: u64,
        /// Minimum amount of token B to receive, prevents excessive slippage
        pub minimum_token_b_amount: u64,
    }

    /// Deposit one token type, exact amount in instruction data
    #[cfg_attr(feature = "fuzz", derive(Arbitrary))]
    #[repr(C)]
    #[derive(Clone, Debug, PartialEq)]
    pub struct DepositSingleTokenTypeExactAmountIn {
        /// Token amount to deposit
        pub source_token_amount: u64,
        /// Pool token amount to receive in exchange. The amount is set by
        /// the current exchange rate and size of the pool
        pub minimum_pool_token_amount: u64,
    }

    /// WithdrawSingleTokenTypeExactAmountOut instruction data
    #[cfg_attr(feature = "fuzz", derive(Arbitrary))]
    #[repr(C)]
    #[derive(Clone, Debug, PartialEq)]
    pub struct WithdrawSingleTokenTypeExactAmountOut {
        /// Amount of token A or B to receive
        pub destination_token_amount: u64,
        /// Maximum amount of pool tokens to burn. User receives an output of token A
        /// or B based on the percentage of the pool tokens that are returned.
        pub maximum_pool_token_amount: u64,
    }

    /// Instructions supported by the token swap program.
    #[repr(C)]
    #[derive(Debug, PartialEq)]
    pub enum SwapInstruction {
        ///   Initializes a new swap
        ///
        ///   0. `[writable, signer]` New Token-swap to create.
        ///   1. `[]` swap authority derived from `create_program_address(&[Token-swap account])`
        ///   2. `[]` token_a Account. Must be non zero, owned by swap authority.
        ///   3. `[]` token_b Account. Must be non zero, owned by swap authority.
        ///   4. `[writable]` Pool Token Mint. Must be empty, owned by swap authority.
        ///   5. `[]` Pool Token Account to deposit trading and withdraw fees.
        ///   Must be empty, not owned by swap authority
        ///   6. `[writable]` Pool Token Account to deposit the initial pool token
        ///   supply.  Must be empty, not owned by swap authority.
        ///   7. `[]` Token program id
        Initialize(Initialize),

        ///   Swap the tokens in the pool.
        ///
        ///   0. `[]` Token-swap
        ///   1. `[]` swap authority
        ///   2. `[]` user transfer authority
        ///   3. `[writable]` token_(A|B) SOURCE Account, amount is transferable by user transfer authority,
        ///   4. `[writable]` token_(A|B) Base Account to swap INTO.  Must be the SOURCE token.
        ///   5. `[writable]` token_(A|B) Base Account to swap FROM.  Must be the DESTINATION token.
        ///   6. `[writable]` token_(A|B) DESTINATION Account assigned to USER as the owner.
        ///   7. `[writable]` Pool token mint, to generate trading fees
        ///   8. `[writable]` Fee account, to receive trading fees
        ///   9. `[]` Token program id
        ///   10. `[optional, writable]` Host fee account to receive additional trading fees
        Swap(Swap),

        ///   Deposit both types of tokens into the pool.  The output is a "pool"
        ///   token representing ownership in the pool. Inputs are converted to
        ///   the current ratio.
        ///
        ///   0. `[]` Token-swap
        ///   1. `[]` swap authority
        ///   2. `[]` user transfer authority
        ///   3. `[writable]` token_a user transfer authority can transfer amount,
        ///   4. `[writable]` token_b user transfer authority can transfer amount,
        ///   5. `[writable]` token_a Base Account to deposit into.
        ///   6. `[writable]` token_b Base Account to deposit into.
        ///   7. `[writable]` Pool MINT account, swap authority is the owner.
        ///   8. `[writable]` Pool Account to deposit the generated tokens, user is the owner.
        ///   9. `[]` Token program id
        DepositAllTokenTypes(DepositAllTokenTypes),

        ///   Withdraw both types of tokens from the pool at the current ratio, given
        ///   pool tokens.  The pool tokens are burned in exchange for an equivalent
        ///   amount of token A and B.
        ///
        ///   0. `[]` Token-swap
        ///   1. `[]` swap authority
        ///   2. `[]` user transfer authority
        ///   3. `[writable]` Pool mint account, swap authority is the owner
        ///   4. `[writable]` SOURCE Pool account, amount is transferable by user transfer authority.
        ///   5. `[writable]` token_a Swap Account to withdraw FROM.
        ///   6. `[writable]` token_b Swap Account to withdraw FROM.
        ///   7. `[writable]` token_a user Account to credit.
        ///   8. `[writable]` token_b user Account to credit.
        ///   9. `[writable]` Fee account, to receive withdrawal fees
        ///   10. `[]` Token program id
        WithdrawAllTokenTypes(WithdrawAllTokenTypes),

        ///   Deposit one type of tokens into the pool.  The output is a "pool" token
        ///   representing ownership into the pool. Input token is converted as if
        ///   a swap and deposit all token types were performed.
        ///
        ///   0. `[]` Token-swap
        ///   1. `[]` swap authority
        ///   2. `[]` user transfer authority
        ///   3. `[writable]` token_(A|B) SOURCE Account, amount is transferable by user transfer authority,
        ///   4. `[writable]` token_a Swap Account, may deposit INTO.
        ///   5. `[writable]` token_b Swap Account, may deposit INTO.
        ///   6. `[writable]` Pool MINT account, swap authority is the owner.
        ///   7. `[writable]` Pool Account to deposit the generated tokens, user is the owner.
        ///   8. `[]` Token program id
        DepositSingleTokenTypeExactAmountIn(DepositSingleTokenTypeExactAmountIn),

        ///   Withdraw one token type from the pool at the current ratio given the
        ///   exact amount out expected.
        ///
        ///   0. `[]` Token-swap
        ///   1. `[]` swap authority
        ///   2. `[]` user transfer authority
        ///   3. `[writable]` Pool mint account, swap authority is the owner
        ///   4. `[writable]` SOURCE Pool account, amount is transferable by user transfer authority.
        ///   5. `[writable]` token_a Swap Account to potentially withdraw from.
        ///   6. `[writable]` token_b Swap Account to potentially withdraw from.
        ///   7. `[writable]` token_(A|B) User Account to credit
        ///   8. `[writable]` Fee account, to receive withdrawal fees
        ///   9. `[]` Token program id
        WithdrawSingleTokenTypeExactAmountOut(WithdrawSingleTokenTypeExactAmountOut),
    }

}